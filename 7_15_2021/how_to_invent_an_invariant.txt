There's a recipe for creating a universal invariant
for some kind of thing that you are interested in.

Step 1: Look for an operation for combining things into things.
Examples include:
* direct sum of vector spaces C^k

Step 2: Imagine `chopping' a thing, all the different ways possible, yielding a sort of formal pile of irreducibles.
* vector space C^k is inexpressible as a direct sum of other vector spaces iff k == 1

Step 3: Double check, we insist on termination - don't allow chopping to continue infinitely.
* this is an invariant of FINITE DIMENSIONAL vector spaces, and like primes and 1, we don't (at the moment) imagine that there is a 0-dimensional vector space that is the unit with respect to direct sum, even if it might be convenient at other times.

Step 4: Force confluence - add `formal' equations among the results of different paths that you could have taken in getting to a pile of irreducibles. Ideally there is some familiar structure such as `associativity and commutativity' that exactly corresponds to `all the different paths that you could have taken'.
* C^2 = C^1 \oplus C^1 implies commutativity
* C^3 = C^1 \oplus (C^1 \oplus C^1) = (C^1 \oplus C^1) \oplus C^1 implies associativity
* Binary commutativity and binary associativity suffice to show confluence

Step 5: Your algebra is the freely-generated one, generated by irreducibles, modulo the relations among the different paths. Your invariant is a computation resulting an element of that algebra.
* The free abelian semigroup on one generator is Nat; this invariant computes a natural number from a 

Step 6: The universal guarantee is that any other computation that both:
1. commutes with the operation that you picked and
2. ends up in the algebra that you ended up in
will `factor through' this invariant.
* In the finite-dimensional vector space example, factor through means that, for example, you could have computed the parity of the dimension instead - but you still could compute the parity of the dimension, starting from the dimension.

Aside: What's frustrating about this, is that it doesn't seem to have a lot more substance or guidance to it. Compare with "Invent a terminating, confluent rewrite system starting from your source objects. Normalization is how you compute the invariant. Your algebraic structure is the set of normal forms. They have algebraic operations corresponding to the signature of the rewrite system; to use the functional analog, just normalize again immediately after constructing a term."

Let's do this over again with sequences of zeroes, ones, and twoes.
[0, 0, 0] and [1, 2, 1] are both sequences of zeroes, ones and twos. Is there an algebraic invariant that could allow us to precompute something small about [0, 0, 0], and similarly something small about [1, 2, 1], that would allow us to compare them for equality without re-processing the "large" sequences themselves?

1. Let's pick appending as a binary operation.
* For example, [0, 0, 0] ++ [1, 2, 1] = [0, 0, 0, 1, 2, 1]

3. Even though the empty sequence is a perfectly good unit with respect to appending, let's forbid it to get termination. So these are finite sequences, and so our irreducibles are going to be [0], [1], [2].

4. We can pick anywhere within the sequence to split. For all x, y, z in {0, 1, 2}, we get:
[x, y, z] = [x] ++ ([y] ++ [z]) = ([x] ++ [y]) ++ [z])
Associativity!

5. The algebra is the freely generated semigroup, generated by [0], [1], [2]. The invariant converts [0, 0, 0] to [0] ++ [0] ++ [0] and [1, 2, 1] to [1] ++ [2] ++ [1] - pretty clearly not losing information, but it's also not smaller or terser.

In order to get something that is "typical" for an invariant, we either need to have constraints, like "sequences which are palindromes", or quotients, like "sequences considered equivalent with respect to renaming",
then the information conveyed by the representation is a bit redundant, and we can get the characteristic "squashing" of a good invariant.

Alternatively, we could try to devise an invariant that is custom-made to distinguish specific things, and "squash away" details that are irelevant.

Let's do "sequences which are palindromes".
Given two small palindromes, one thing that we could do that would make a bigger palindrome would be to append them, and then reflect, creating an odd-length palindrome by reusing one letter if the last letter equals the first.

a + b = abba
aba + aca = abaacacaaba

Alternately, something we could do that would split a palindrome into two smaller palindromes is to identify two corresponding letters on each side of the center and cut the big palindrome into the center section, and the outer section with that center excised.

abaacacaaba = cac + abaaaaba

What do we get as indecomposibles each way?

Each letter is indecomposable via append-and-reflect.
aba is indecomposable via append-and-reflect
abcba is indecompsable via append-and-reflect
abcdcba is indecomposable via append-and-reflect
abadaba is decomposable as aba + d
aabbaa is decomposable as aa + b
aabaa is indecomposable via append-and-reflect


Let's do this over again with matrices.

TODO

Let's do this over again with graphs.

The Tutte polynomial arises via a decomposition of a graph into:
1. a graph formed from the original by deletion of a particular (non-loop, non-bridge) edge
2. a graph formed from the original by contraction of a particular (non-loop, non-bridge) edge

The binary operation is called "+".

Note that there is an injective-on-vertices map from the deletion to the original, and a surjective-on-vertices map from the original to the contraction. 

The indecomposables are graphs formed of only bridges and loops - that is trees, with some subset of their nodes decorated with self-loops. The Tutte polynomial collapses this to a two-parameter family x^i y^j where i is the number of bridges and j is the number of self-loops. A disconnected graph with zero edges gets 1. 

I am somewhat disappointed; the "no bridge no self loop" and the two-parameter family doesn't seem right; if it turns out to be a polynomial in two parameters, then I expect there to be two fundamental indecomposables.

Maybe we continue the recursion with two more relations:
4. If it has a non-bridge, non-self-loop edge, then the answer is Recurse(contraction) + Recurse(deletion)
2. If it has at least one edge, and that edge is a bridge, then the answer is X * Recurse(deletion)
3. If it has at least one edge, and that edge is a self-loop, then the answer is Y * Recurse(deletion)
1. If it has zero edges, then the answer is 1


Let's do this over again with posets.

I think this story is Mobius inversion?
https://en.wikipedia.org/wiki/Incidence_algebra
https://math.stackexchange.com/questions/1072025/interpreting-the-m%C3%B6bius-function-of-a-poset
Is this story the same as Richard Stanley 1973?
http://www-math.mit.edu/~rstan/pubs/pubfiles/15.pdf

