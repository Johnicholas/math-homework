1. Regarding Ax-Grothendieck:
This is a theorem that, in certain circumstances, something that is known to be an injection, is actually a bijection.

Discussed here:
https://terrytao.wordpress.com/2009/03/07/infinite-fields-finite-fields-and-the-ax-grothendieck-theorem/
which is elaborated on here:
https://math.osu.edu/sites/math.osu.edu/files/AxGrothendieck.pdf
and references this:
https://arxiv.org/abs/0903.0517
also references this, which gives a rough dictionary for analogies between `hard' and `soft' analysis:
https://terrytao.wordpress.com/2007/05/23/soft-analysis-hard-analysis-and-the-finite-convergence-principle/

There are two simpler situations:
1. If a function from a finite set to itself is injective, then it is bijective.
2. If a polynomial function from the reals to themselves is injective, then it is bijective.

The way the Ax-Grothendieck proof proceeds, as far as I understand it (which is not very far), is something like this: a polynomial over finite fields that is an injection is a bijection (because of the simpler situation 1),
However, if, in the infinitary situations that Ax-Grothendieck applies to, there was a counter example, then there would be a corresponding, finitary, "shadow" counterexample, which would be a contradiction.

2. one-hot and thermometer correspondences
You might fix a correspondence 
available between the numbers 0 through n and 
the dimensions or basis vectors of a n-dimensional linear space.

This is possibly similar to a "one-hot" representation in neural networks.
An alternative representation that is sometimes used is the "thermometer" representation,
where the numbers 0 through n correspond to the vectors with
the initial dimensions 1 and later dimensions 0, like this:
(1, 0, 0, ..., 0)
(1, 1, 0, 0, ..., 0)
(1, 1, ..., 1)
There are N thermometer vectors spanning N dimensions, or N+1 if we include the all-zeroes vector as a thermometer vector?).
There are N one-hot vectors spanning N dimensions.

I think there are a pair of 3 by 3 matrices for converting back and forth between these,
What is the utility and/or categorification of this one-hot <-> thermometer correspondence?

3. The factorial formula

There is a factorial formula https://en.wikipedia.org/wiki/Binomial_coefficient#Multiplicative_formula
choose N K = N! / K! (N - K)!
shich makes me think that something like quotienting a set of size N! such as the elements of S_N, the symmetric group on N elements,
by some equivalence relation? relating to permutations of K things (the items being selected?) and permutations of (N-K) things
(the spaces being left behind?).

4. Monoids and Commutative Monoids

I have another sense, which is that monoids and/or deterministic finite automata could be involved.
Certainly if you have a set of strings, and then you run them through a finite automaton,
then the states where they land will partition the set of strings.
If you know that a string landed in a particular state, then you may be able to
wield the state's regular expression to get a sort of decompression, or interleaving, or synchronizing function.

Suppose that you have the free monoid on two generators a and b.
Suppose that you have a finite string of a and b.
Then you can navigate, using that string, to an element; that element `is' the finite string.

Suppose that you have the free commutative monoid on two generators a and b.
Suppose that you have a set-with-multiplicity of a and b (a function from {a, b} to Nat?).
Then you can navigate, using that string, to an element of the free commutative monoid.
That element `is' the set-with-multiplicity.

Suppose that you have a finite string of a and b.
You can measure the length of that string.
That is, you can map it to the free monoid on one generator by identifying a and b.
Furhtermore, you can map that to the free commutative monoid on one generator (though that does not do much).

This square commutes:
If you start with a finite string of a and b, like abaaab,
and map it into a free commutative monoid on two generators, like a^3 b^2,
and then "measure" it (identify a and b and map it to the free commutative monoid on one generator), like 5,
then you end up at the same spot as if you had measured it (mapped to the free monoid on one generator), like 5,
and then enforced commutativity on that (also 5).
That's true, but I'm not sure that it's going anywhere.

The cardinality of the preimage of a particular element a^x b^y of the free commutative monoid on two generators,
in the map from the free monoid to the free commutative monoid, will be the binomial {n+m choose n}.

What's the category-theoretic analog of that statement? 

The cardinality-analog of the preimage-analog of the element-analog of the free-commutative-monoid-analog,
in the map from the free-monoid-analog to the free-commutative-monoid-analog

Maybe cardinality-analog is https://ncatlab.org/nlab/show/groupoid+cardinality

Maybe preimages are a kind of pullback.

A particular element is an arrow from the terminal object to an object.

Freeness is a universal property, maybe the inital object in some category?
There's a monoid to commutative monoid free+forgetful adjunction, too.


4. Look it up in nlab! https://ncatlab.org/nlab/show/binomial+theorem#combinatorial_interpretation





What is that thing about I and N - I?
Each of the summands on the right hand side of the binomial theorem seems to correspond to a (ordered) subset of N.

If we have binary products,
then we 



We have a pair of two things, the left hand side is tagged with either `A' or `B',
while the right hand side is tagged with a whole index datatype.
We can do an isomorphism, where we first view the tags (and construe all the tags together as a single thing),
and then, given that, we know what we have (and we view that all together as a single thing).

The fancy tags are something like strings of `A' or `B'.
The thing that we do with them is transform
1. A pair of a function from I to A and a function from (N - I) to B to a function from N to (A - B)

Let's talk about fancy coproducts.
A binary coproduct, we talk about 1 and 2 without discussing what kind of thing they are,
or where they live, or what operations are possible on them.
A fancy coproduct, we use big-sum notation, and we need to discuss what kind of thing the
indexes are, or what operations are possible on them.





A generic fancy coproduct, viewed from the outside,
looks like a map from the index set to the coproduct of the terms,
with some guarantees.

If you have an element of the fancy coproduct (a map 1 \to FancyCoproduct)
then you compose to get an element of the index (a map 1 \to Index).

If you ``recognize'' that element of the index, you can use a guarantee that you might have lying around
to obtain a bijection between the preimage of that element and some nicely structured set.

What happens if you take a binary product with a binary coproduct on the one side, and a fancy coproduct on the other side?

Well, what happens if you take a binary product with a binary coproduct on the one side, and a binary coproduct on the other side?
(A + B) * (C + D)
Elements of this set are pairs.
The left side of the pairs are `tagged' with `A' or `B', while the right hand side are tagged with `C' or `D'.
What can we do with this?





In writing a proof, `turning over a card' corresponds to analysis by cases;
In writing a program, `turning over a card' corresponds to pattern matching or definition by cases.

In writing a proof, `


In this case, what we can do that's maybe a categorification of distribution of multiplication is
to inspect the tag of the first element of the pair, and inspect the tag of the second element of the pair,
and pair up the values.
Pair (Union {A, B} A B) (Union {C, D} C D)
= Union {AC, AD, BC, BD} (Pair A C) (Pair A D) (Pair B C) (Pair B D) 

What is the universal property of this resulting object?
Well, it's a coproduct, so:
IT = Union {AC, AD, BC, BD} (Pair A C) (Pair A D) (Pair B C) (Pair B D) 
has an injection function i from the index set {AC, AD, BC, BD} \to maps from Pair (A + B) (C + D) to IT,
such that any other pair of 
1. a coproduct-like object Y, with
2. with an injection-like function f from {AC, AD, BC, BD} \to maps from from Pair (A + B) (C + D) to IT
then
there is a unique morphism from IT to Y
such that
i {AC, AD, BC, BD} ; f = f {AC, AD, BC, BD}













